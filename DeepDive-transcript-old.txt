Hello everyone! I hope you're enjoying JuliaCon!

Slide 00.1

Today I'm going to be giving a deep dive into creating shared libraries with PackageCompiler.jl. This is a companion to the lightning talk that has hopefully already been shown. In this talk I'll give more technical details than in the lightning talk.

Slide00.2

Here's an overview of will be talking about first will give a little motivation as to why we did this.  I will talk about the anatomy of a Julia installation, including how PackageCompiler.jl packages it up. Will discuss creating a shared library with Julia and will give an example of linking to the library from both C and rust. 

Slide 01.1

So why are we working on this?  At our company, we have a real time code base in rust and we had some optimization algorithms written in Python that we wanted to run as part of this code base. While it's possible to call Python from rust, writing high-performance Python can be challenging (as you probably know) especially code that needs to run in real time. We tried porting this code to rust, and while it would have been possible, it was also quite challenging. Porting this Python code to Julia on the other hand was actually extremely easy, and instead of spending time porting Python to rust, we instead spent the same time figuring out an easy way to call Julia from rust.

Slide – 01.2
Now, there are a number of alternatives for calling functions written in Julia from other languages. In fact, people have been embedding Julia in other programs almost since Julia was released. There is a whole manual chapter on how to embed Julia. There are also many options for calling code written in Julia from other languages, including rust. The jlrs package for rust follows a very similar paradigm to the embedding Julia chapter. The problem with this approach, at least from our perspective, is that it's cumbersome. One of Julia's selling points is multiple dispatch, and both the embedding chapter and jlrs attempt to give you full access to this mechanism. However, since neither C nor rust have multiple dispatch the process of calling Julia methods is complicated. We wanted something simpler.

Before I go on I’d like to give a shout out to StaticCompiler.jl. This package attempts to use LLVM to generate C libraries directly. It hasn't seen much activity recently, but I'm hopeful that approach like this will eventually be available.

Slide –01.3

So I'm guessing you might be interested in this problem if you fall into one of following use cases. You might have an existing see C++, or rust, or similar language that can call out to C libraries. And you might have the need for specific scientific numerical or other functionality that is easier to write in Julia, and hard to write in your target language. Also, while is not required, this approach works particularly well if you have code that is running inside docker containers. 

Slide –01.4

There are also cases where you might want to choose a different approach. Obviously, if Julie is the primary language of your other code base, you have no need for this. It's also the case that our approach is not at all lightweight. It pulls in much of the Julia compiler infrastructure, just not in a way that requires Julia to be preinstalled.

Also, if you need to call into Julia from multiple different threads in the target language, our approach is challenging, although you can still of course use multiple threads within Julia.

Finally if you have multiple Julia-based libraries that you need to install, you'll need to create a single package which pulls all of them in in Julia before they can be used from your target language.

Slide –02.0

The work to create shared libraries here reuses much of the work that PackageCompiler.jl already does. As a reminder one of the purposes of PackageCompiler.jl is to create self-contained app bundles which take Julia, any necessary artifacts, and a little bit of additional code, replace the repl entry point, and bundle it in a way that makes the code relocatable meaning that it can be installed anywhere on a target system.

Slide –02.1

Let's take a look at exactly what a Julia installation consists of, so that we can see what needs to be bundled together.

Here with cut out a bit of detail, but at the highest level, a Julie installation consists of a bin directory, a Lib directory, and a shared directory. The bin directory contains the Julia executable itself. The live directory contains all of the libraries that make up Julia, or that are required by a basic Julia installation

Slide –02.2

Additionally, Julia users have a Julia directory with various user specific files, including packages that they installed and artifacts, which are additional shared libraries used by packages. If we want to bundle up an application or a library, much of this will also have to be included.

Slide –02.3

When you create an app with PackageCompiler.jl, this is what it creates. Notice that instead of a Julie executable there is no one application-specific binary, as well as a Julius this image in the bin directory.

Slide –02.5

The structure of a Julia based library is very similar, with some differences. The bin directory is gone, and there is a new include directory. There is also a new mylib.so file in the Lib directory, and artifacts are tucked under share/julia.

Slide –02.6

So what is libmylib.so? It's a system image! And, it's also a C library!

That means that to Julia, it needs to include things that let it act like a sys image. And that for other languages to use it, it needs to export C functions which run the Julia functions we wish to call.

Slide –03.1

In our lightning talk, I gave a simple example of how this can be done. For any function we wish to export, we simply annotated it with Base.@ccallable, and make sure it is typed in a way that C understands.

Slide –03.2

Then, when we call create_library,…

Slide –04.1

… PackageCompiler.jl will generate the library bundle that we saw earlier. This is what it looks like on Linux.

Slide –04.2

Here it is on OSX.

Slide –04.3

And this is what it looks like on Windows. Notice here that there is no live directory, and that everything is under bin. On Windows, it's hard to find libraries relative to a binary, and so the most common and easiest thing to do is to place the shared libraries in the same directory as binary you are generating. PackageCompiler.jl tries to facilitate this, although we are open to suggestions if there are Windows developers who have better ideas.

Slide – 04.4

One last thing I'd like to add is that because were including a mostly complete Julia installation, and where calling into Julia code, we still need to initialize and shut down Julia. PackageCompiler.jl compiles two additional functions into the system image for this purpose.

Slide –04.5

They look like this



